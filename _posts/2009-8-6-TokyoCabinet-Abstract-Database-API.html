---
layout: default
title: Tokyo Cabinet的Abstract Database API
---

<h4>简介</h4>
<div class="dl50">
抽象データベースは、オンメモリハッシュデータベースとオンメモリツリーデータベースとハッシュデータベースとB+木データベースと固定長データベースとテーブルデータベースを同一のAPIで抽象化したデータベースです。それを扱うのが抽象データベースAPIです。`tcadb.h' にAPIの仕様の完全な記述があります。
</div>

<div class="dl50">
<h4>Tokyo Cabinet的数据结构分为</h4>
<ul>
<li>1.Hash结构</li>
<li>2.B+Tree</li>
<li>3.定长数据库</li>
</ul>
<h4>但无论哪种数据结构,最后都会抽象为以下操作,以及分别对应不同的API</h4>
<ul>
<li>put</li>
Hash: bool tchdbput2(TCHDB *hdb, const char *kstr, const char *vstr);<br>
B+Tree: bool tcbdbput2(TCBDB *bdb, const char *kstr, const char *vstr);<br>
Table: bool tctdbput3(TCTDB *tdb, const char *pkstr, const char *cstr);<br>
<li>get</li>
Hash: char *tchdbget2(TCHDB *hdb, const char *kstr);<br>
B+Tree: char *tcbdbget2(TCBDB *bdb, const char *kstr);<br>
Table: char *tctdbget3(TCTDB *tdb, const char *pkstr);<br>
</ul>

这样,就为开发相应的接口,增加了不少复杂度,需要针对不同的数据结构,去调用不同的API,但Abstract Database API有效减少了这个麻烦,看下面的代码
{% highlight c %}
TCADB *adb = tcadbnew();
if(!tcadbopen(adb, dbname)) {
    fprintf(stderr, "open error: %s\n", dbname);
}
tcadbput2(adb, key, value);
if(!tcadbclose(adb)){
    fprintf(stderr, "close error:");
    return 0;
}
tcadbdel(adb);
{% endhighlight %}
一个tcadbput2,就可以代替所有的put方法了,adb是通过判断所操作数据库的扩展名,来决定调用哪种数据库的API,扩展名对应如下:
<ul>
<li>Hash: .tch</li>
<li>B+Tree: .tcb</li>
<li>定长数据库: .tcf</li>
</ul>

<h4>特殊API的调用</h4>
在特殊情况下,不同的数据结构,又提供了一些自己独有的API,例如B+Tree,可以添加重复的key,这时就需要用到tcbdbputdup2方法,用adb如何调用呢,看代码
{% highlight c %}
TCADB *adb = tcadbnew();
if(!tcadbopen(adb, dbname)) {
    fprintf(stderr, "open error: %s\n", dbname);
}
tcbdbputdup2(adb->bdb, key, value);
if(!tcadbclose(adb)){
    fprintf(stderr, "close error:");
    return 0;
}
tcadbdel(adb);
{% endhighlight %}
通过adb->bdb就可以指定现在的抽象数据库为一个B+Tree数据库,其他数据库的获取方式如下:<br>
<ul>
<li>Hash: adb->hdb</li>
<li>B+Tree: adb->bdb</li>
<li>定长数据库: adb->fdb</li>
</ul>

</div>



